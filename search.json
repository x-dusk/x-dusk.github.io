[{"title":"Docker笔记（二）应用的容器化（Dockerfile）","url":"/2020/04/09/docker-two/","content":"## 一、简介\n&#8194; &#8194;&#8194;&#8194;将应用程序整合到容器中进行运行的过程，称为应用的“容器化”，也可以叫做“Docker化”。一个应用程序在代码编写，测试完成之后，还要面临在生产环境的构建，部署，运维等一系列繁杂的问题，开发人员与运维人员也许要经过多次的协调沟通才能将一个应用成功投入生产。设想如果将应用程序转变成一个容器，那些与应用运行所需环境相关的问题就几乎都不存在了，开发只需要专注于应用代码的开发，稍微加上一点“如何将应用变成容器”的说明工作，而运维人员只需要统一考虑容器的运行管理就可以了，本文就来介绍这个“如何将应用变成容器”的工作---应用的容器化。\n\n## 二、应用容器化的整体流程\n&#8194; &#8194;&#8194;&#8194;容器化可以简化应用的构建、部署和运行过程，我们先大体掌握以下主要流程步骤：\n![应用容器化的整体流程](https://img-blog.csdnimg.cn/20191126212743389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZmNvZGU=,size_16,color_FFFFFF,t_70)\n<!-- <center></center> -->\n\n1.编写应用代码\n2.在应用主目录下，创建一个Dockerfile，其中包括当前应用的描述、环境依赖、以及如何运行这个应用\n3.在应用主目录下，对Dockerfile文件执行docker image build命令\n4.等待Docker将应用程序构建到Docker镜像中\n5.一旦应用被打包成了一个Docker镜像，就能以镜像的形式交付、转移、团队分享等，并以Docker容器的方式运行了\n注意，Dockerfile文件首字母必须大写，这是Docker image build默认寻找的Dockerfile文件名，当然其实也可以通过-f 来指定Dockerfile的文件名，只不过一般情况下没有必要\n\n## 三、Dockerfile详解\nDockerfile的两个主要作用：\n\n1.对当前应用的描述\n2.指导Docker完成应用的容器化，从构建至运行\n\n打开一个Dockerfile文件，看一下具体长什么样子：\n\n```powershell\n$ cat Dockerfile\n\n# Dockerfile of Example\n# Version 1.0\n# Base Images\nFROM centos\nLABEL maintainer=\"you@example.com\"\nRUN yum install -y --update nodejs nodejs-npm\nCOPY . /src\nWORKDIR /src\nRUN npm install\nEXPOSE 8080\nENTRYPOINT [\"node\", \"./app.js\"]\n```\nDockerfile中的注释以#开头，除注释之外的每一行都是一条指令（Instruction）\n指令的格式：INSTRUCTION args，指令不区分大小写，但建议指令大写，增强Dockerfile的可读性\ndocker image build命令会按行一行一行来解析Dockerfile中的指令，并顺序执行\n\n对上面Dockerfile示例文件的解读：\n```powershell\nFROM centos    //以centos镜像作为当前镜像的基础，也就是上一篇中讲的基础镜像层\nLABEL maintainer=\"you@example.com\"    //指定维护者（maintainer)为“you@example.com”，元数据，不会添加新的镜像层，建议添加上维护者信息，这样可以给镜像潜在使用者提供沟通途径。\nRUN yum install -y --update nodejs nodejs-npm    //在centos上用yum安装Nodejs和NPM到当前镜像中，新建镜像层\nCOPY . /src    //将当前目录中的所有文件（也就是应用代码）复制到镜像中，并新建镜像层\nWORKDIR /src    //设置当前的工作目录，后续指令在此目录下执行，会作为元数据记录到镜像配置中，不会创建镜像层\nRUN npm instal    //执行npm install安装依赖文件到镜像中，并创建镜像层\nEXPOSE 8080    //指定应用的网络端口，通过8080端口对外提供Web服务，属于容器内的端口，元数据，不会新建镜像层\nENTRYPOINT [\"node\", \"./app.js\"]    //最后将app.js设置为镜像默认运行的应用，元数据，不会新建镜像层\n```\n表1  Dockerfile常用操作指令\n指令\t含义\nFROM 镜像\t指定基础镜像，第一条指令必须为FROM，每创建一个镜像就需要一条FROM\nMAINTAINER 名字\t说明镜像的维护者信息\nRUN 命令\t在所基于的镜像上执行命令，并提交到新的镜像中\nCMD[\"要运行的程序\",\"参数一\",\"参数二\"]\t启动容器时要运行的命令或脚本，只能有一条CMD命令，如果有多个，执行最后一个\nEXPOSE 端口号\t指定新镜像加载到Docker时需要开启的端口，也就是容器监听连接者的端口\nENV 环境变量 变量值\t设置一个环境变量比如path，会被RUN，CMD等指令用到，还可以定义版本信息便于维护\nADD 源文件/目录 目标文件/目录\t复制文件，源文件要和Dockerfile同级目录，与COPY不同是源文件可以是url\nCOPY 源文件/目录 目标文件/目录\t复制文件，源文件要和Dockerfile同级目录\nVOLUME [\"目录\"]\t在容器中创建一个挂载点，里面存放的数据在容器销毁后仍然存在\nUSER 用户名/UID\t指定运行容器时的用户\nWORKDIR 路径\t\n为在该条命令之后的RUN，CMD，ENTRYPOINT指定工作目录，建议绝对路径\n\nENTRYPOINT [\"运行的程序\",\"若干参数\"]\t指定镜像以容器方式启动后默认运行的程序\nHEALTHCHECK\t健康检查\n两个比较：\n\n# COPY和ADD  \nADD是有更复杂语义的复制文件，COPY就是单纯的复制文件，ADD支持源文件是url远程下载，如果源文件是压缩文件，ADD指令会自动解压，复杂语义会带来一定的不确定性，因此建议复制文件就用明确的COPY\n# CMD和ENTRYPOINT  \n这两个命令是在镜像运行的时候执行的，RUN是在镜像构建的时候执行的，ENTRYPOINT一般指示镜像的主程序入口，CMD中的在和ENTRYPOINT同时存在时作为ENTRYPOINT的参数，Docker run 后附加的参数会被附加在ENTRYPOINT的后面。推荐的做法是ENTRYPOINT作为镜像的主命令，CMD来设定参数。\n\n## 四、从Dockerfile构建镜像\n进入应用主目录，执行如下命令：\n```powershell\ndocker image build -t mywebapp:latest -f Dockerfile.dev .\n```\n-t 指定镜像标签，-f 指定Dockerfile的路径和名称，如果不写，代表是当前目录下的Dockerfile，最后那个点.不能丢，代表从当前目录构建。\n\n镜像构建完成后，可以从镜像启动容器：\n```powershell\ndocker run -d --name c1 -p 80:8080 mywebapp:latest\n```\n-d 让应用程序以守护进程的形式后台运行，-p 80：8080表示将主机的80端口映射到容器内的8080端口，--name 为容器起个名字，代替容器ID方便后续命令使用。\n```powershell\n.Dockerignore文件\n```\n类似Git的.gitignore文件，Docker也有自己的构建忽略，就是.Dockerignore文件，像一些temp临时文件，测试文件，.git目录，*.md文件等，不必要放入Docker镜像中，在Docker镜像的构建过程中，加入.Dockerignore文件，可以提高构建效率。\n\n## 五、Dockerfile的一些原则及注意事项\n避免安装非必要软件包，如文本编辑器，辅助工具等\n一个容器只运行一个进程，便于对每个容器进行监控和调优，也便于集群扩容或缩容。\n镜像层尽量保持最少，COPY，RUN，ADD指令会创建镜像层，不要随意使用这些命令\n多行参数分割，如果安装的软件包很多，建议按照字母顺序排序，并用反斜杠\\换行分割，增强Dockerfile可读性\nFROM指令建议使用官方提供的版本，不建议使用上百M的ubuntu，centos，建议使用轻量级安全的Alpine linux\nDockerfile文件要看作程序的组成部分，加入Git等版本控制\n## 六、总结\n&#8194; &#8194;&#8194;&#8194;本文主要介绍了通过Dockerfile将自己的应用构建成Docker容器的过程，主要以单体应用的构建为例，至于多容器的应用用到的Docker Compose，以及Docker Swarm集群，后续了解的更为深入时再来介绍。\n","tags":["docker"]},{"title":"Docker笔记（一）概念理解及常用命令","url":"/2020/04/09/first-blog/","content":"### 简介\n本文主要介绍Docker必知概念和必会使用方法，适合想要了解docker技术和学习docker日常使用的读者。\n## Docker起源---容器\n&#8194; &#8194;&#8194;&#8194;最早，一台服务器只能运行同类的单一应用，想要增加一个新的应用，需要采购一个新的服务器，为了解决服务器资源严重浪费的问题，虚拟机(VM)技术出现了，但是像VMwave，VisualBox这些虚拟机技术并非十全十美，最大的问题是每个虚拟机都要有一个操作系统，这些OS会占用额外的CPU和RAM---这些资源本可以用于运行更多的应用，同时由于启动速度慢，可移植性差等问题，**容器(Container)技术**开始发展起来，容器的运行不会再独占操作系统，启动速度快，便于迁移，可以说解决了虚拟机时代的“顽疾”。\n&#8194; &#8194;&#8194;&#8194;容器技术起源于Linux，是开源社区长期努力持续贡献的产物，但因为早期容器技术过于复杂，并没有真正被大众所接受，直到Docker的出现。\n## Docker---让容器变得简单\n&#8194;&#8194;&#8194;&#8194;Docker是一种用**Go语言**开发的用于**创建**、**运行**，**管理**、**编排容器**的**开源软件**，是GitHub上**Moby开源项目**的一部分，位于旧金山的Docker公司是整个Moby项目的维护者。Docker公司致力于“将Docker和容器技术推向全世界”，有一说一，正是Docker这家公司**让容器变得简单**，**Linux容器技术**才得到了广泛的应用。近几年**微软**也和Docker公司、社区进行了深入合作，促进Docker和容器技术在**Windows平台**的发展，Mac系统上也可以用Docker for Mac来运行Linux容器，虽然这是通过在Mac上启动一个轻量级Linux虚拟机来运行Linux容器的，但这种方式至少方便了开发人员在Mac上开发和调试Linux容器。\n## Docker的几个重要的概念\n* **Docker引擎**：docker引擎是**用于运行和编排容器的基础设施工具**，可以认为常说的Docker就是指Docker引擎。Docker引擎主要由以下组件构成：==Docker客户端（Docker Client）==，==Docker守护进程（Docker Daemon)==，==containerd==以及==runc==。它们共同负责容器的创建和运行。\n* **Docker架构**：C/S架构（Client/Server），Client主要负责传递Docker命令，容器的管理，编排等在Server侧（Docker守护进程，containerd等）来完成。从图中可以看到Docker正逐步走向模块化，容器的执行逻辑和运行代码下放给了下层的containerd和runc，Docker daemon成为了更高层的管理者，负责镜像管理，安全特性，RESTful API等。\n*![Docker引擎架构](https://img-blog.csdnimg.cn/2019112011250976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZmNvZGU=,size_16,color_FFFFFF,t_70)\n<center>图一 Docker架构</center>\n\n* **Docker镜像**：镜像可以理解为**构建容器的模板**，更进一步可以理解为**面向对象中的类(Class)**，镜像内部由**精简的操作系统文件**，**应用运行所必须的文件和依赖包**，和**运行容器所需的配置参数(环境变量)**等组成。镜像对外看是一个只读的文件集合的整体，镜像对内是**分层叠加**实现的，这里的分层可以理解为**构建镜像过程中的不同阶段镜像的不同版本**，举一个例子，基于ubuntu18.04构建一个镜像，这就是这个镜像的第一层，然后再装上python包，这就是第二层，再加上安全补丁就是第三层，后续每次做的添加都是一层，最终构建时Docker负责**堆叠**这些层形成一个整体的镜像。这样松耦合分层堆叠的好处是可以在不同镜像之间**共享镜像层**，这是由Docker的存储引擎自动实现的。\n（1）镜像体积一般很小，Docker官方Alpine linux镜像只有4MB，Windows镜像会比较大\n（2）从**一个镜像可以启动一个或多个容器**（传入的参数不同或运行的端口不同），所有的容器没有全部停止或销毁，对应的镜像**无法删除**\n（3）从面向对象的角度来看，**镜像是类，容器是对象**，镜像是静态的，容器是运行时的镜像 \n（4）镜像仓库服务：Docker镜像存储在**镜像仓库服务**（Image Registry）中，Docker客户端默认使用官方公共仓库服务[Docker Hub](https://hub.docker.com/search/)，也可配置私有仓库服务，包含多个仓库，每个仓库可以有多个镜像\n![镜像仓库服务](https://img-blog.csdnimg.cn/20191120172928567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZmNvZGU=,size_16,color_FFFFFF,t_70)\n<center>图二 镜像仓库服务</center>\n\n（5) Docker安装之后，本地并没有镜像，**需要从镜像仓库服务拉取镜像到本地**，linux Docker本地镜像仓库通常位于/var/lib/docker/\\<storage-driver>\n（6）镜像命名和标签：官方仓库中通过**镜像的名字**和**标签**（中间用：分割）定位一个镜像。从官方仓库拉取镜像的命令是：\n\n```powershell\ndocker image pull <repository>:<tag>\ndocker image pull redis:latest //从官方redis仓库拉取标签为latest的镜像\ndocker image pull mysql:5.6 //从官方仓库中拉取标签为5.6的mysql镜像，标签一般就是版本号\ndocker image pull mysql //不写tag则Docker会默认拉取tag为latest的镜像\n```\n（7）注意，latest未必是仓库中最新的镜像，**一个镜像可以有多个标签**，`docker image pull -a mysql`,会拉取该mysql仓库中的**所有镜像**，`docker image ls`命令会列出**本地仓库所有的镜像**\n（8）通过Docker命令行搜索Docker Hub上的镜像：`docker search name`\n\n```bash\ndocker search mysql //搜索仓库名或者非官方仓库的组织名中含有mysql的镜像\n```\n返回的结果中既有官方又有非官方的，使用`- -filter`可以进行过滤，使用`- -limit`可以对返回内容做限制。\n\n```powershell\ndocker search mysql -f \"is-official=true\" --limit 30\n```\n（9）查看镜像分层：该命令会**展示镜像的细节**，包括**镜像层数据**和**镜像元数据**。\n\n```powershell\n$ docker image inspect mysql:5.7\n[\n\t{\n\t\t\"Id\":\"sha256:bdfs8dffd...\",\n\t\t\"RepoTags\":[\n\t\t\t\"mysql:5.7\"\n\t\t\t],\n\t\t\"RootFS\":{\n\t\t\t\"Type\":\"layers\",\n\t\t\t\"Layers\":[\n\t\t\t\t\"sha256:c8a75145fc...894129005e461a43875a094b93412\",\n   \t\t\t\t\"sha256:c6f2b330b6...7214ed6aac305dd03f70b95cdc610\",\n   \t\t\t\t\"sha256:055757a193...3a9565d78962c7f368d5ac5984998\",\n   \t\t\t\t\"sha256:4837348061...12695f548406ea77feb5074e195e3\",\n   \t\t\t\t\"sha256:0cad5e07ba...4bae4cfc66b376265e16c32a0aae9\"\n\t\t\t]\n\t\t}\n\t}\n]\n```\n（10）删除镜像：删除操作会删除当前主机上的该镜像以及**相关的镜像层**，但如果某个镜像层被多个镜像共享，则只有所有**依赖该镜像层的镜像都被删除了该镜像层才会被删除**。如果镜像**有正在运行的容器**，则也不被允许删除。\n\n```powershell\ndocker image rm mysql:5.7 //删除mysql5.7的镜像\ndocker image rm [id] //删除镜像ID为[id]的镜像\ndocker image rm $(docker image ls -q) -f //删除本地系统中的全部镜像\n```\n## Docker容器\n（1）容器是镜像的**运行时实例**。可以认为是镜像的一次运行，或者说运行状态的镜像，**一个镜像可以启动多个容器**。![一个镜像运行多个容器](https://img-blog.csdnimg.cn/201911202024383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZmNvZGU=,size_16,color_FFFFFF,t_70)\n<center>图三 一个镜像可以运行多个容器</center>\n\n（2）容器vs虚拟机\n&#8194;&#8194;&#8194;&#8194;容器和虚拟机都依赖于宿主机才能运行，两者都属于**虚拟化技术**，最大的不同在于，**虚拟机是硬件级别的虚拟化**，在物理机的基础上进行硬件的虚拟化，将物理资源划分为虚拟资源，然后在上面安装一个个操作系统，再在操作系统上安装应用。而**容器是在操作系统级别的虚拟化**，将操作系统的资源划分为虚拟资源，上层在这些虚拟资源上构建容器应用，所有容器公用同一个宿主机操作系统。![硬件虚拟化的虚拟机技术](https://img-blog.csdnimg.cn/20191120203820790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZmNvZGU=,size_16,color_FFFFFF,t_70)\n\n<center>图四 虚拟机技术结构示意</center>\n\n![操作系统虚拟化的容器技术](https://img-blog.csdnimg.cn/20191120203921988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZmNvZGU=,size_16,color_FFFFFF,t_70)\n<center>图五 容器技术结构示意</center>\n\n（3）运行容器\n第一步，先检查Docker是否在运行：\n\n```powershell\ndocker version //显示docker客户端和服务端守护进程的信息，说明docker已经运行\n\nservice docker status //linux系统下执行 显示docker的运行状态\n```\n然后，用`docker container run <options> <image>:<tag> <app>`来创建并启动一个**新容器**，image为镜像名，tag为标签，app为运行在容器中的程序，命令中container可以省略\n\n```powershell\ndocker run --name ubu -it ubuntu:latest /bin/bash //linux 示例 在ubuntu容器中运行一个bash终端\n\ndocker run -it microsoft/powershell:nanoserver pwsh.exe //windows 示例\n```\n-i ------**让容器的输入保持打开状态**\n-t ------**让Docker分配一个伪终端**\n--name -------**给容器起一个名字，可以代替长串的容器ID**\n期间发生的事情：**命令回车之后，Docker客户端选择合适的API调用Docker daemon，Docker daemon先看本地仓库是否有该镜像，然后再去Docker Hub查询对应镜像，最后将镜像拉取到本地，创建容器并在其中运行指定的程序。**\n（4）容器进程\n&#8194;&#8194;&#8194;&#8194;在容器中执行`ps -elf`可以查看容器中正在运行的进程，默认有一个bash进程，如果没有别的进程，输入exit退出，会导致容器进程也被杀死，容器中至少有一个进程才能存在。按下`ctrl P+Q`组合键可以不终止容器运行地退出容器。\n\n```powershell\ndocker container ls //列出当前系统正在运行的容器列表\n\ndocker exec -it <containerId> /bin/bash //docker exec命令会创建一个新的bash终端连接\n到正在运行的容器\n```\n（5）容器生命周期\n**新建并启动**一个容器`docker run --name test_mysql -it mysql:5.7 /bin/bash`\n等同于`docker create + docker start`\n**停止**一个容器：`docker stop test_mysql`\n查看全部**处于运行状态**的容器：`docker container ls`\n查看**包括停止状态**的**所有**容器：`docker container ls -a`\n**打开一个关闭的容器**：`docker start test_mysql`\n**删除**一个容器：`docker container rm test_mysql`，最好**先stop容器**，加-f是强制删除，不推荐\n（6）**容器端口映射**\n在容器中运行需要指定端口的应用（如web服务器）时，需要指定容器的端口映射\n\n```powershell\ndocker run -d --name test_tomcat -p 80:8080 tomcat:8.5.34\n```\n-d ------表示后台运行，-it是交互式运行\n-p ------[**Docker主机端口**]:[**容器端口**]，这意味着当外界有请求打到Docker主机的80端口时，请求会被映射到容器内的8080端口，容器内的web服务器监听8080端口就可以收到请求。\n（6）容器启动的**默认行为**\n&#8194;&#8194;&#8194;&#8194;镜像中包含了容器启动时指定的默认应用，所以有时在`docker run`启动一个容器的时候，默认启动了一些进程。如官方提供的web服务器等。可以通过`docker image inspect image:tag`来查看\n\n```powershell\n[\n{\n\"Id\": \"sha256:07e574331ce3768f30305519...49214bf3020ee69bba1\",\n\"RepoTags\": [\n  \"tomcat:latest\n],\n\"Cmd\": [ //cmd为容器将会执行的命令或者应用\n  \"/bin/sh\",\n  \"-c\",\n  \"#(nop) CMD [\\\"/bin/sh\\\" \\\"-c\\\" \\\"cd /src java \\\n  .\\\"]\"\n]\n```\n## 常用命令\n（1）查看本地所有镜像：`docker images`\n（2）查看本地所有正在运行的容器的状态：`docker ps`，加个-a可以列出所有容器的状态：`docker ps -a`\n（3）容器的导入导出：\n导出：`docker export 容器ID或名称 > 文件名`\n\n```powershell\ndocker export test_mysql > exp_mysql\n```\n\n导入：`cat 文件名| docker import - 生成的镜像名称:标签`\n\n```powershell\ncat exp_mysql | docker import - local_mysql:test\n```\n（4）查看端口映射：`docker port [imageID]或者[name]`\n（5）查看容器内部输出：`docker logs -f 容器id或者名字 ` 该命令可以像tail -f一样，打印出容器内部的标准输出。\n（6）查看容器内部进程：`docker top 容器id或者名字`\n（7）容器与宿主机之间复制文件：\n①容器内文件复制到宿主机：`docker cp 容器id或名字:/path 宿主机目的路径`\n```powershell\ndocker cp test_mysql:/test.txt  /home/temp/\n```\n②宿主机文件复制到容器内：`docker cp 宿主机文件或目录 容器id或名字:/path/ `\n\n```powershell\ndocker cp /root/test.txt  test_mysql:/path/\n```\n## 总结\n本文主要介绍了Docker入门须知的一些概念，以及**运维角度**下常用的一些知识点，下章介绍**开发角度**下的Docker，重点是**Dockerfile**。\n## 参考资料\n1.《[深入浅出Docker](https://book.douban.com/subject/30486354/)》作者: [英]奈吉尔· 波尔顿（Nigel Poulton）人民邮电出版社\n2.《[Docker容器技术与高可用实战](https://book.douban.com/subject/33410747/)》作者: 肖睿 刘震 人民邮电出版社\n\n","tags":["docker","总结"]},{"title":"Hello World","url":"/2020/04/09/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]